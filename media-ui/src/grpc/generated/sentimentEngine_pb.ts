// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file sentimentEngine.proto (package sentiment, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * Enum representing different model types for sentiment analysis.
 *
 * @generated from enum sentiment.ModelType
 */
export enum ModelType {
  /**
   * Model that analyzes both voice and text.
   *
   * @generated from enum value: VOICE_TEXT = 0;
   */
  VOICE_TEXT = 0,

  /**
   * Model that analyzes text only.
   *
   * @generated from enum value: TEXT_ONLY = 1;
   */
  TEXT_ONLY = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ModelType)
proto3.util.setEnumType(ModelType, "sentiment.ModelType", [
  { no: 0, name: "VOICE_TEXT" },
  { no: 1, name: "TEXT_ONLY" },
]);

/**
 * Enum for the types of dialog request payloads.
 *
 * @generated from enum sentiment.DialogRequestPayloadType
 */
export enum DialogRequestPayloadType {
  /**
   * Indicates the start of the processing.
   *
   * @generated from enum value: PROCESS_START = 0;
   */
  PROCESS_START = 0,

  /**
   * Indicates that processing is ongoing.
   *
   * @generated from enum value: PROCESSING = 1;
   */
  PROCESSING = 1,

  /**
   * Indicates that processing has ended.
   *
   * @generated from enum value: PROCESS_END = 2;
   */
  PROCESS_END = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DialogRequestPayloadType)
proto3.util.setEnumType(DialogRequestPayloadType, "sentiment.DialogRequestPayloadType", [
  { no: 0, name: "PROCESS_START" },
  { no: 1, name: "PROCESSING" },
  { no: 2, name: "PROCESS_END" },
]);

/**
 * Enum for the status of the processing response.
 *
 * @generated from enum sentiment.ProcessResponse
 */
export enum ProcessResponse {
  /**
   * Processing has started.
   *
   * @generated from enum value: PROCESS_STARTED = 0;
   */
  PROCESS_STARTED = 0,

  /**
   * Processing is currently in progress.
   *
   * @generated from enum value: IN_PROGRESS = 1;
   */
  IN_PROGRESS = 1,

  /**
   * Sentiment for a segment is available.
   *
   * @generated from enum value: SEGMENT_SENTIMENT_AVAILABLE = 2;
   */
  SEGMENT_SENTIMENT_AVAILABLE = 2,

  /**
   * Processing has completed.
   *
   * @generated from enum value: PROCESS_ENDED = 3;
   */
  PROCESS_ENDED = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(ProcessResponse)
proto3.util.setEnumType(ProcessResponse, "sentiment.ProcessResponse", [
  { no: 0, name: "PROCESS_STARTED" },
  { no: 1, name: "IN_PROGRESS" },
  { no: 2, name: "SEGMENT_SENTIMENT_AVAILABLE" },
  { no: 3, name: "PROCESS_ENDED" },
]);

/**
 * The request message for streaming media or text analysis.
 *
 * @generated from message sentiment.SentimentRequest
 */
export class SentimentRequest extends Message<SentimentRequest> {
  /**
   * Unique identifier for the request.
   *
   * @generated from field: string identifier = 1;
   */
  identifier = "";

  /**
   * Type of the payload being processed (start, ongoing, end).
   *
   * @generated from field: sentiment.DialogRequestPayloadType payload_type = 2;
   */
  payloadType = DialogRequestPayloadType.PROCESS_START;

  /**
   * Identifier for the participant submitting the request.
   *
   * @generated from field: string participant_id = 3;
   */
  participantId = "";

  /**
   * Oneof to specify the input type: either media (binary) or text (string).
   *
   * @generated from oneof sentiment.SentimentRequest.input_type
   */
  inputType: {
    /**
     * Media data for sentiment analysis.
     *
     * @generated from field: bytes media = 4;
     */
    value: Uint8Array;
    case: "media";
  } | {
    /**
     * Text data for sentiment analysis.
     *
     * @generated from field: string text = 5;
     */
    value: string;
    case: "text";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Type of sentiment analysis model to be used.
   *
   * @generated from field: sentiment.ModelType model_type = 6;
   */
  modelType = ModelType.VOICE_TEXT;

  /**
   * Voice Activity Detection time in milliseconds.
   *
   * @generated from field: int32 vad_time = 7;
   */
  vadTime = 0;

  /**
   * Version of the model being used for analysis.
   *
   * @generated from field: string model_version = 8;
   */
  modelVersion = "";

  /**
   * Additional metadata for the request (key-value pairs).
   *
   * @generated from field: map<string, string> metadata = 9;
   */
  metadata: { [key: string]: string } = {};

  /**
   * Pointer scheme to indicate how to handle the input.
   *
   * @generated from field: int32 pointer_scheme = 10;
   */
  pointerScheme = 0;

  /**
   * Indicates if a transcription response is required.
   *
   * @generated from field: bool transcription_response = 11;
   */
  transcriptionResponse = false;

  constructor(data?: PartialMessage<SentimentRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sentiment.SentimentRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "payload_type", kind: "enum", T: proto3.getEnumType(DialogRequestPayloadType) },
    { no: 3, name: "participant_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "media", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "input_type" },
    { no: 5, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "input_type" },
    { no: 6, name: "model_type", kind: "enum", T: proto3.getEnumType(ModelType) },
    { no: 7, name: "vad_time", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 8, name: "model_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "metadata", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "scalar", T: 9 /* ScalarType.STRING */} },
    { no: 10, name: "pointer_scheme", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 11, name: "transcription_response", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SentimentRequest {
    return new SentimentRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SentimentRequest {
    return new SentimentRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SentimentRequest {
    return new SentimentRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SentimentRequest | PlainMessage<SentimentRequest> | undefined, b: SentimentRequest | PlainMessage<SentimentRequest> | undefined): boolean {
    return proto3.util.equals(SentimentRequest, a, b);
  }
}

/**
 * Error message structure for reporting issues during sentiment analysis.
 *
 * @generated from message sentiment.Error
 */
export class Error extends Message<Error> {
  /**
   * Unique error code.
   *
   * @generated from field: string code = 1;
   */
  code = "";

  /**
   * Description of the error.
   *
   * @generated from field: string message = 2;
   */
  message = "";

  constructor(data?: PartialMessage<Error>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sentiment.Error";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Error {
    return new Error().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Error {
    return new Error().fromJsonString(jsonString, options);
  }

  static equals(a: Error | PlainMessage<Error> | undefined, b: Error | PlainMessage<Error> | undefined): boolean {
    return proto3.util.equals(Error, a, b);
  }
}

/**
 * The response message containing the sentiment analysis result for each utterance.
 *
 * @generated from message sentiment.SentimentResponse
 */
export class SentimentResponse extends Message<SentimentResponse> {
  /**
   * Unique identifier for the response.
   *
   * @generated from field: string identifier = 1;
   */
  identifier = "";

  /**
   * Identifier for the participant associated with the response.
   *
   * @generated from field: string participant_id = 2;
   */
  participantId = "";

  /**
   * Identifier for the segment of text or media analyzed.
   *
   * @generated from field: string segment_id = 3;
   */
  segmentId = "";

  /**
   * Current status of the processing response.
   *
   * @generated from field: sentiment.ProcessResponse process_status = 4;
   */
  processStatus = ProcessResponse.PROCESS_STARTED;

  /**
   * Start time of the segment in microseconds.
   *
   * @generated from field: string start_time = 5;
   */
  startTime = "";

  /**
   * End time of the segment in microseconds.
   *
   * @generated from field: string end_time = 6;
   */
  endTime = "";

  /**
   * sentiments identified in the analysis.
   *
   * @generated from field: string sentiment = 7;
   */
  sentiment = "";

  /**
   * Transcription of the analyzed media or text.
   *
   * @generated from field: string transcription = 8;
   */
  transcription = "";

  /**
   * Version of the model used for sentiment analysis.
   *
   * @generated from field: string model_version = 9;
   */
  modelVersion = "";

  /**
   * Confidence score of the sentiment analysis (0.0 to 1.0).
   *
   * @generated from field: float confidence = 10;
   */
  confidence = 0;

  /**
   * Error information, if any occurred during processing.
   *
   * @generated from field: sentiment.Error error = 11;
   */
  error?: Error;

  constructor(data?: PartialMessage<SentimentResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sentiment.SentimentResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "identifier", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "participant_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "segment_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "process_status", kind: "enum", T: proto3.getEnumType(ProcessResponse) },
    { no: 5, name: "start_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "end_time", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "sentiment", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "transcription", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "model_version", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 10, name: "confidence", kind: "scalar", T: 2 /* ScalarType.FLOAT */ },
    { no: 11, name: "error", kind: "message", T: Error },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SentimentResponse {
    return new SentimentResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SentimentResponse {
    return new SentimentResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SentimentResponse {
    return new SentimentResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SentimentResponse | PlainMessage<SentimentResponse> | undefined, b: SentimentResponse | PlainMessage<SentimentResponse> | undefined): boolean {
    return proto3.util.equals(SentimentResponse, a, b);
  }
}

/**
 * Message representing a ping request
 *
 * @generated from message sentiment.PingRequest
 */
export class PingRequest extends Message<PingRequest> {
  /**
   * The ping message content
   *
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<PingRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sentiment.PingRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PingRequest {
    return new PingRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PingRequest {
    return new PingRequest().fromJsonString(jsonString, options);
  }

  static equals(a: PingRequest | PlainMessage<PingRequest> | undefined, b: PingRequest | PlainMessage<PingRequest> | undefined): boolean {
    return proto3.util.equals(PingRequest, a, b);
  }
}

/**
 * Message representing a pong response
 *
 * @generated from message sentiment.PongResponse
 */
export class PongResponse extends Message<PongResponse> {
  /**
   * The pong message content
   *
   * @generated from field: string message = 1;
   */
  message = "";

  constructor(data?: PartialMessage<PongResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "sentiment.PongResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): PongResponse {
    return new PongResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): PongResponse {
    return new PongResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): PongResponse {
    return new PongResponse().fromJsonString(jsonString, options);
  }

  static equals(a: PongResponse | PlainMessage<PongResponse> | undefined, b: PongResponse | PlainMessage<PongResponse> | undefined): boolean {
    return proto3.util.equals(PongResponse, a, b);
  }
}

