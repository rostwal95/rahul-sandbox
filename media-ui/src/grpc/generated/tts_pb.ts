//
//This proto contains all the messages required for tts synthesize service

// @generated by protoc-gen-es v1.10.0 with parameter "target=ts"
// @generated from file tts.proto (package com.cisco.wcc.ccai.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 *
 * Gender of the voice as described in
 * [SSML voice element](https://www.w3.org/TR/speech-synthesis11/#edef_voice).
 *
 * @generated from enum com.cisco.wcc.ccai.v1.SsmlVoiceGender
 */
export enum SsmlVoiceGender {
  /**
   *
   * An unspecified gender.
   * In VoiceSelectionParams, this means that the client doesn't care which
   * gender the selected voice will have. In the Voice field of
   * ListVoicesResponse, this may mean that the voice doesn't fit any of the
   * other categories in this enum, or that the gender of the voice isn't known.
   *
   * @generated from enum value: SSML_VOICE_GENDER_UNSPECIFIED = 0;
   */
  SSML_VOICE_GENDER_UNSPECIFIED = 0,

  /**
   * A male voice.
   *
   * @generated from enum value: MALE = 1;
   */
  MALE = 1,

  /**
   * A female voice.
   *
   * @generated from enum value: FEMALE = 2;
   */
  FEMALE = 2,

  /**
   * A gender-neutral voice. This voice is not yet supported.
   *
   * @generated from enum value: NEUTRAL = 3;
   */
  NEUTRAL = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SsmlVoiceGender)
proto3.util.setEnumType(SsmlVoiceGender, "com.cisco.wcc.ccai.v1.SsmlVoiceGender", [
  { no: 0, name: "SSML_VOICE_GENDER_UNSPECIFIED" },
  { no: 1, name: "MALE" },
  { no: 2, name: "FEMALE" },
  { no: 3, name: "NEUTRAL" },
]);

/**
 *
 * Represents the output audio encoding formats
 *
 * @generated from enum com.cisco.wcc.ccai.v1.OutputAudioEncoding
 */
export enum OutputAudioEncoding {
  /**
   * Not specified.
   *
   * @generated from enum value: OUTPUT_ENCODING_UNSPECIFIED = 0;
   */
  OUTPUT_ENCODING_UNSPECIFIED = 0,

  /**
   * Uncompressed 16-bit signed little-endian samples (Linear PCM).
   *
   * @generated from enum value: OUTPUT_LINEAR16 = 1;
   */
  OUTPUT_LINEAR16 = 1,

  /**
   * 8-bit samples that compound 14-bit audio samples using G.711 PCMU/mu-law.
   *
   * @generated from enum value: OUTPUT_MULAW = 2;
   */
  OUTPUT_MULAW = 2,

  /**
   * G.711 A-law, 8kHz
   *
   * @generated from enum value: OUTPUT_ALAW = 3;
   */
  OUTPUT_ALAW = 3,

  /**
   * MP3 audio at 32kbps.
   *
   * @generated from enum value: OUTPUT_MP3 = 4;
   */
  OUTPUT_MP3 = 4,

  /**
   *
   * Opus encoded audio wrapped in an ogg container. The result will be a
   * file which can be played natively on Android, and in browsers (at least
   * Chrome and Firefox). The quality of the encoding is considerably higher
   * than MP3 while using approximately the same bitrate.
   *
   * @generated from enum value: OGG_OPUS = 5;
   */
  OGG_OPUS = 5,
  MULAW,
}
// Retrieve enum metadata with: proto3.getEnumType(OutputAudioEncoding)
proto3.util.setEnumType(OutputAudioEncoding, "com.cisco.wcc.ccai.v1.OutputAudioEncoding", [
  { no: 0, name: "OUTPUT_ENCODING_UNSPECIFIED" },
  { no: 1, name: "OUTPUT_LINEAR16" },
  { no: 2, name: "OUTPUT_MULAW" },
  { no: 3, name: "OUTPUT_ALAW" },
  { no: 4, name: "OUTPUT_MP3" },
  { no: 5, name: "OGG_OPUS" },
]);

/**
 *
 * Description of a voice supported by the TTS service.
 *
 * @generated from message com.cisco.wcc.ccai.v1.Voice
 */
export class Voice extends Message<Voice> {
  /**
   * The languages that this voice supports, expressed as
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tags (e.g.
   * "en-US", "es-419", "cmn-tw").
   *
   * @generated from field: string voice_language = 1;
   */
  voiceLanguage = "";

  /**
   * The name of this voice.  Each distinct voice has a unique name.
   *
   * @generated from field: string voice_name = 2;
   */
  voiceName = "";

  /**
   * The gender of this voice.
   *
   * @generated from field: com.cisco.wcc.ccai.v1.SsmlVoiceGender voice_gender = 3;
   */
  voiceGender = SsmlVoiceGender.SSML_VOICE_GENDER_UNSPECIFIED;

  /**
   * The natural sample rate (in hertz) for this voice.
   *
   * @generated from field: int32 voice_rate = 4;
   */
  voiceRate = 0;

  constructor(data?: PartialMessage<Voice>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.Voice";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "voice_language", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "voice_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "voice_gender", kind: "enum", T: proto3.getEnumType(SsmlVoiceGender) },
    { no: 4, name: "voice_rate", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Voice {
    return new Voice().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Voice {
    return new Voice().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Voice {
    return new Voice().fromJsonString(jsonString, options);
  }

  static equals(a: Voice | PlainMessage<Voice> | undefined, b: Voice | PlainMessage<Voice> | undefined): boolean {
    return proto3.util.equals(Voice, a, b);
  }
}

/**
 *
 * Contains text input to be synthesized. Either `text` or `ssml` must be
 * supplied. Supplying both or neither returns
 * [google.rpc.Code.INVALID_ARGUMENT][]. The input size is limited to 5000
 * characters.
 *
 * @generated from message com.cisco.wcc.ccai.v1.SpeakInput
 */
export class SpeakInput extends Message<SpeakInput> {
  /**
   * The input source, which is either plain text or SSML.
   *
   * @generated from oneof com.cisco.wcc.ccai.v1.SpeakInput.input_source
   */
  inputSource: {
    /**
     * The raw text to be synthesized.
     *
     * @generated from field: string text = 1;
     */
    value: string;
    case: "text";
  } | {
    /**
     * The SSML document to be synthesized. The SSML document must be valid
     * and well-formed. Otherwise the RPC will fail and return
     * [google.rpc.Code.INVALID_ARGUMENT][]. For more information, see
     * [SSML](https://cloud.google.com/text-to-speech/docs/ssml).
     *
     * @generated from field: string ssml = 2;
     */
    value: string;
    case: "ssml";
  } | {
    /**
     * The URL which needs to be fetched and played.
     *
     * @generated from field: string url = 3;
     */
    value: string;
    case: "url";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<SpeakInput>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.SpeakInput";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "text", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "input_source" },
    { no: 2, name: "ssml", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "input_source" },
    { no: 3, name: "url", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "input_source" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeakInput {
    return new SpeakInput().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeakInput {
    return new SpeakInput().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeakInput {
    return new SpeakInput().fromJsonString(jsonString, options);
  }

  static equals(a: SpeakInput | PlainMessage<SpeakInput> | undefined, b: SpeakInput | PlainMessage<SpeakInput> | undefined): boolean {
    return proto3.util.equals(SpeakInput, a, b);
  }
}

/**
 *
 * Description of which voice to use for a synthesis request.
 *
 * @generated from message com.cisco.wcc.ccai.v1.SpeakerParams
 */
export class SpeakerParams extends Message<SpeakerParams> {
  /**
   *
   * Required. The language (and potentially also the region) of the voice expressed as a
   * [BCP-47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt) language tag, e.g.
   * "en-US". This should not include a script tag (e.g. use
   * "cmn-cn" rather than "cmn-Hant-cn"), because the script will be inferred
   * from the input provided in the SynthesisInput.  The TTS service
   * will use this parameter to help choose an appropriate voice.  Note that
   * the TTS service may choose a voice with a slightly different language code
   * than the one selected; it may substitute a different region
   * (e.g. using en-US rather than en-CA if there isn't a Canadian voice
   * available), or even a different language, e.g. using "nb" (Norwegian
   * Bokmal) instead of "no" (Norwegian)".
   *
   * @generated from field: string language_code = 1;
   */
  languageCode = "";

  /**
   *
   * The name of the voice. If not set, the service will choose a
   * voice based on the other parameters such as language_code and gender.
   *
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   *
   * The preferred gender of the voice. If not set, the service will
   * choose a voice based on the other parameters such as language_code and
   * name. Note that this is only a preference, not requirement; if a
   * voice of the appropriate gender is not available, the synthesizer should
   * substitute a voice with a different gender rather than failing the request.
   *
   * @generated from field: com.cisco.wcc.ccai.v1.SsmlVoiceGender ssml_gender = 3;
   */
  ssmlGender = SsmlVoiceGender.SSML_VOICE_GENDER_UNSPECIFIED;

  /**
   * Type of the Voice e.g. Neural, Enhanced, Standard etc  
   *
   * @generated from field: string model = 4;
   */
  model = "";

  constructor(data?: PartialMessage<SpeakerParams>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.SpeakerParams";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "language_code", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "ssml_gender", kind: "enum", T: proto3.getEnumType(SsmlVoiceGender) },
    { no: 4, name: "model", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SpeakerParams {
    return new SpeakerParams().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SpeakerParams {
    return new SpeakerParams().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SpeakerParams {
    return new SpeakerParams().fromJsonString(jsonString, options);
  }

  static equals(a: SpeakerParams | PlainMessage<SpeakerParams> | undefined, b: SpeakerParams | PlainMessage<SpeakerParams> | undefined): boolean {
    return proto3.util.equals(SpeakerParams, a, b);
  }
}

/**
 * Description of audio data to be synthesized.
 *
 * @generated from message com.cisco.wcc.ccai.v1.AudioConfig
 */
export class AudioConfig extends Message<AudioConfig> {
  /**
   * Required. The format of the audio byte stream.
   *
   * @generated from field: com.cisco.wcc.ccai.v1.OutputAudioEncoding audio_encoding = 1;
   */
  audioEncoding = OutputAudioEncoding.OUTPUT_ENCODING_UNSPECIFIED;

  /**
   *
   * Optional. Input only. Speaking rate/speed, in the range [0.25, 4.0]. 1.0 is
   * the normal native speed supported by the specific voice. 2.0 is twice as
   * fast, and 0.5 is half as fast. If unset(0.0), defaults to the native 1.0
   * speed. Any other values < 0.25 or > 4.0 will return an error.
   *
   * @generated from field: double speaking_rate = 2;
   */
  speakingRate = 0;

  /**
   *
   * Optional. Input only. Speaking pitch, in the range [-20.0, 20.0]. 20 means
   * increase 20 semitones from the original pitch. -20 means decrease 20
   * semitones from the original pitch.
   *
   * @generated from field: double pitch = 3;
   */
  pitch = 0;

  /**
   *
   * Optional. Input only. Volume gain (in dB) of the normal native volume
   * supported by the specific voice, in the range [-96.0, 16.0]. If unset, or
   * set to a value of 0.0 (dB), will play at normal native signal amplitude. A
   * value of -6.0 (dB) will play at approximately half the amplitude of the
   * normal native signal amplitude. A value of +6.0 (dB) will play at
   * approximately twice the amplitude of the normal native signal amplitude.
   * Strongly recommend not to exceed +10 (dB) as there's usually no effective
   * increase in loudness for any value greater than that.
   *
   * @generated from field: double volume_gain_db = 4;
   */
  volumeGainDb = 0;

  /**
   * Optional. The synthesis sample rate (in hertz) for this audio.
   *
   * @generated from field: int32 sample_rate_hertz = 5;
   */
  sampleRateHertz = 0;

  /**
   * Required. The desired voice of the synthesized audio.
   *
   * @generated from field: com.cisco.wcc.ccai.v1.SpeakerParams voice = 6;
   */
  voice?: SpeakerParams;

  constructor(data?: PartialMessage<AudioConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.AudioConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "audio_encoding", kind: "enum", T: proto3.getEnumType(OutputAudioEncoding) },
    { no: 2, name: "speaking_rate", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 3, name: "pitch", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "volume_gain_db", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 5, name: "sample_rate_hertz", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 6, name: "voice", kind: "message", T: SpeakerParams },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AudioConfig {
    return new AudioConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AudioConfig {
    return new AudioConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AudioConfig {
    return new AudioConfig().fromJsonString(jsonString, options);
  }

  static equals(a: AudioConfig | PlainMessage<AudioConfig> | undefined, b: AudioConfig | PlainMessage<AudioConfig> | undefined): boolean {
    return proto3.util.equals(AudioConfig, a, b);
  }
}

/**
 *
 * This contains a mapping between a certain point in the input text and a
 * corresponding time in the output audio.
 *
 * @generated from message com.cisco.wcc.ccai.v1.Timepoint
 */
export class Timepoint extends Message<Timepoint> {
  /**
   * Timepoint name as received from the client within `<mark>` tag.
   *
   * @generated from field: string mark_name = 4;
   */
  markName = "";

  /**
   * Time offset in seconds from the start of the synthesized audio.
   *
   * @generated from field: double time_seconds = 3;
   */
  timeSeconds = 0;

  constructor(data?: PartialMessage<Timepoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.Timepoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "mark_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "time_seconds", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Timepoint {
    return new Timepoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Timepoint {
    return new Timepoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Timepoint {
    return new Timepoint().fromJsonString(jsonString, options);
  }

  static equals(a: Timepoint | PlainMessage<Timepoint> | undefined, b: Timepoint | PlainMessage<Timepoint> | undefined): boolean {
    return proto3.util.equals(Timepoint, a, b);
  }
}

/**
 *
 * Represents the Provider object used in list providers api
 *
 * @generated from message com.cisco.wcc.ccai.v1.Provider
 */
export class Provider extends Message<Provider> {
  /**
   * Provider id
   *
   * @generated from field: string provider_id = 1;
   */
  providerId = "";

  /**
   * Provider Name
   *
   * @generated from field: string provider_name = 2;
   */
  providerName = "";

  constructor(data?: PartialMessage<Provider>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.Provider";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "provider_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Provider {
    return new Provider().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Provider {
    return new Provider().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Provider {
    return new Provider().fromJsonString(jsonString, options);
  }

  static equals(a: Provider | PlainMessage<Provider> | undefined, b: Provider | PlainMessage<Provider> | undefined): boolean {
    return proto3.util.equals(Provider, a, b);
  }
}

/**
 *
 * Represents the Provider Voice object mentioning the provider and voice information
 *
 * @generated from message com.cisco.wcc.ccai.v1.ProviderVoices
 */
export class ProviderVoices extends Message<ProviderVoices> {
  /**
   * @generated from field: com.cisco.wcc.ccai.v1.Provider provider = 1;
   */
  provider?: Provider;

  /**
   * @generated from field: repeated com.cisco.wcc.ccai.v1.Voice voice = 2;
   */
  voice: Voice[] = [];

  constructor(data?: PartialMessage<ProviderVoices>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "com.cisco.wcc.ccai.v1.ProviderVoices";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "provider", kind: "message", T: Provider },
    { no: 2, name: "voice", kind: "message", T: Voice, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProviderVoices {
    return new ProviderVoices().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProviderVoices {
    return new ProviderVoices().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProviderVoices {
    return new ProviderVoices().fromJsonString(jsonString, options);
  }

  static equals(a: ProviderVoices | PlainMessage<ProviderVoices> | undefined, b: ProviderVoices | PlainMessage<ProviderVoices> | undefined): boolean {
    return proto3.util.equals(ProviderVoices, a, b);
  }
}

